{"ast":null,"code":"// @tensorflow/tfjs-models Copyright 2019 Google\nimport { loadGraphModel, util, tensor2d, tensor1d } from \"@tensorflow/tfjs\";\n\nfunction __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function a(e) {\n      try {\n        s(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function l(e) {\n      try {\n        s(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function s(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(a, l);\n    }\n\n    s((r = r.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var n,\n      r,\n      o,\n      i,\n      a = {\n    label: 0,\n    sent: function sent() {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: l(0),\n    throw: l(1),\n    return: l(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function l(i) {\n    return function (l) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; a;) {\n          try {\n            if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n            switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n              case 0:\n              case 1:\n                o = i;\n                break;\n\n              case 4:\n                return a.label++, {\n                  value: i[1],\n                  done: !1\n                };\n\n              case 5:\n                a.label++, r = i[1], i = [0];\n                continue;\n\n              case 7:\n                i = a.ops.pop(), a.trys.pop();\n                continue;\n\n              default:\n                if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                  a = 0;\n                  continue;\n                }\n\n                if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                  a.label = i[1];\n                  break;\n                }\n\n                if (6 === i[0] && a.label < o[1]) {\n                  a.label = o[1], o = i;\n                  break;\n                }\n\n                if (o && a.label < o[2]) {\n                  a.label = o[2], a.ops.push(i);\n                  break;\n                }\n\n                o[2] && a.ops.pop(), a.trys.pop();\n                continue;\n            }\n\n            i = t.call(e, a);\n          } catch (e) {\n            i = [6, e], r = 0;\n          } finally {\n            n = o = 0;\n          }\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, l]);\n    };\n  }\n}\n\nfunction __awaiter$1(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function a(e) {\n      try {\n        s(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function l(e) {\n      try {\n        s(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function s(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(a, l);\n    }\n\n    s((r = r.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator$1(e, t) {\n  var n,\n      r,\n      o,\n      i,\n      a = {\n    label: 0,\n    sent: function sent() {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: l(0),\n    throw: l(1),\n    return: l(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function l(i) {\n    return function (l) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; a;) {\n          try {\n            if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n            switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n              case 0:\n              case 1:\n                o = i;\n                break;\n\n              case 4:\n                return a.label++, {\n                  value: i[1],\n                  done: !1\n                };\n\n              case 5:\n                a.label++, r = i[1], i = [0];\n                continue;\n\n              case 7:\n                i = a.ops.pop(), a.trys.pop();\n                continue;\n\n              default:\n                if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                  a = 0;\n                  continue;\n                }\n\n                if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                  a.label = i[1];\n                  break;\n                }\n\n                if (6 === i[0] && a.label < o[1]) {\n                  a.label = o[1], o = i;\n                  break;\n                }\n\n                if (o && a.label < o[2]) {\n                  a.label = o[2], a.ops.push(i);\n                  break;\n                }\n\n                o[2] && a.ops.pop(), a.trys.pop();\n                continue;\n            }\n\n            i = t.call(e, a);\n          } catch (e) {\n            i = [6, e], r = 0;\n          } finally {\n            n = o = 0;\n          }\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, l]);\n    };\n  }\n}\n\nvar stringToChars = function stringToChars(e) {\n  for (var t = [], n = 0, r = e; n < r.length; n++) {\n    var o = r[n];\n    t.push(o);\n  }\n\n  return t;\n},\n    TrieNode = function () {\n  function e(e) {\n    this.key = e, this.parent = null, this.children = {}, this.end = !1;\n  }\n\n  return e.prototype.getWord = function () {\n    for (var e = [], t = this; null !== t;) {\n      null !== t.key && e.unshift(t.key), t = t.parent;\n    }\n\n    return [e, this.score, this.index];\n  }, e;\n}(),\n    Trie = function () {\n  function e() {\n    this.root = new TrieNode(null);\n  }\n\n  return e.prototype.findAllCommonPrefixes = function (e, t, n) {\n    if (t.end) {\n      var r = t.getWord();\n      e.slice(0, r[0].length).join(\"\") === r[0].join(\"\") && n.unshift(r);\n    }\n\n    for (var o in t.children) {\n      this.findAllCommonPrefixes(e, t.children[o], n);\n    }\n  }, e.prototype.insert = function (e, t, n) {\n    for (var r = this.root, o = stringToChars(e), i = 0; i < o.length; i++) {\n      r.children[o[i]] || (r.children[o[i]] = new TrieNode(o[i]), r.children[o[i]].parent = r), r = r.children[o[i]], i === o.length - 1 && (r.end = !0, r.score = t, r.index = n);\n    }\n  }, e.prototype.commonPrefixSearch = function (e) {\n    var t = this.root.children[e[0]],\n        n = [];\n    return t ? this.findAllCommonPrefixes(e, t, n) : n.push([[e[0]], 0, 0]), n;\n  }, e;\n}(),\n    separator = \"▁\";\n\nfunction processInput(e) {\n  var t = e.normalize(\"NFKC\");\n  return separator + t.replace(/ /g, separator);\n}\n\nvar RESERVED_SYMBOLS_COUNT = 6,\n    Tokenizer = function () {\n  function e(e) {\n    this.vocabulary = e, this.trie = new Trie();\n\n    for (var t = RESERVED_SYMBOLS_COUNT; t < this.vocabulary.length; t++) {\n      this.trie.insert(this.vocabulary[t][0], this.vocabulary[t][1], t);\n    }\n  }\n\n  return e.prototype.encode = function (e) {\n    var t = [],\n        n = [],\n        r = [];\n    e = processInput(e);\n\n    for (var o = stringToChars(e), i = 0; i <= o.length; i++) {\n      t.push({}), n.push(0), r.push(0);\n    }\n\n    for (i = 0; i < o.length; i++) {\n      for (var a = this.trie.commonPrefixSearch(o.slice(i)), l = 0; l < a.length; l++) {\n        var s = a[l],\n            u = {\n          key: s[0],\n          score: s[1],\n          index: s[2]\n        };\n        null == t[i + (c = s[0].length)][i] && (t[i + c][i] = []), t[i + c][i].push(u);\n      }\n    }\n\n    for (var c = 0; c <= o.length; c++) {\n      for (var h in t[c]) {\n        var f = t[c][h];\n\n        for (l = 0; l < f.length; l++) {\n          var d = f[l],\n              p = d.score + r[c - d.key.length];\n          (0 === r[c] || p >= r[c]) && (r[c] = p, n[c] = f[l].index);\n        }\n      }\n    }\n\n    for (var v = [], y = n.length - 1; y > 0;) {\n      v.push(n[y]), y -= this.vocabulary[n[y]][0].length;\n    }\n\n    var b = [],\n        g = !1;\n\n    for (i = 0; i < v.length; i++) {\n      var _ = v[i];\n      g && 0 === _ || b.push(_), g = 0 === _;\n    }\n\n    return b.reverse();\n  }, e;\n}(),\n    BASE_PATH = \"https://storage.googleapis.com/tfjs-models/savedmodel/universal_sentence_encoder/\";\n\nfunction loadTokenizer(e) {\n  return __awaiter$1(this, void 0, void 0, function () {\n    var t;\n    return __generator$1(this, function (n) {\n      switch (n.label) {\n        case 0:\n          return [4, loadVocabulary(e)];\n\n        case 1:\n          return t = n.sent(), [2, new Tokenizer(t)];\n      }\n    });\n  });\n}\n\nfunction loadVocabulary(e) {\n  return void 0 === e && (e = BASE_PATH + \"vocab.json\"), __awaiter$1(this, void 0, void 0, function () {\n    return __generator$1(this, function (t) {\n      switch (t.label) {\n        case 0:\n          return [4, fetch(e)];\n\n        case 1:\n          return [2, t.sent().json()];\n      }\n    });\n  });\n}\n\nvar BASE_PATH$1 = \"https://storage.googleapis.com/tfjs-models/savedmodel/toxicity/\";\n\nfunction load$1(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    var n;\n    return __generator(this, function (r) {\n      switch (r.label) {\n        case 0:\n          return [4, (n = new ToxicityClassifier(e, t)).load()];\n\n        case 1:\n          return r.sent(), [2, n];\n      }\n    });\n  });\n}\n\nvar ToxicityClassifier = function () {\n  function e(e, t) {\n    void 0 === e && (e = .85), void 0 === t && (t = []), this.threshold = e, this.toxicityLabels = t;\n  }\n\n  return e.prototype.loadModel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return [2, loadGraphModel(BASE_PATH$1 + \"model.json\")];\n      });\n    });\n  }, e.prototype.loadTokenizer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return [2, loadTokenizer()];\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e,\n          t,\n          n,\n          r = this;\n      return __generator(this, function (o) {\n        switch (o.label) {\n          case 0:\n            return [4, Promise.all([this.loadModel(), this.loadTokenizer()])];\n\n          case 1:\n            return e = o.sent(), t = e[0], n = e[1], this.model = t, this.tokenizer = n, this.labels = t.outputs.map(function (e) {\n              return e.name.split(\"/\")[0];\n            }), 0 === this.toxicityLabels.length ? this.toxicityLabels = this.labels : util.assert(this.toxicityLabels.every(function (e) {\n              return r.labels.indexOf(e) > -1;\n            }), function () {\n              return \"toxicityLabels argument must contain only items from the model heads \" + r.labels.join(\", \") + \", got \" + r.toxicityLabels.join(\", \");\n            }), [2];\n        }\n      });\n    });\n  }, e.prototype.classify = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t,\n          n,\n          r,\n          o,\n          i,\n          a,\n          l,\n          s = this;\n      return __generator(this, function (u) {\n        switch (u.label) {\n          case 0:\n            for (\"string\" == typeof e && (e = [e]), t = e.map(function (e) {\n              return s.tokenizer.encode(e);\n            }), n = t.map(function (e, t) {\n              return e.map(function (e, n) {\n                return [t, n];\n              });\n            }), r = [], o = 0; o < n.length; o++) {\n              r = r.concat(n[o]);\n            }\n\n            return i = tensor2d(r, [r.length, 2], \"int32\"), a = tensor1d(util.flatten(t), \"int32\"), [4, this.model.executeAsync({\n              Placeholder_1: i,\n              Placeholder: a\n            })];\n\n          case 1:\n            return l = u.sent(), i.dispose(), a.dispose(), [2, l.map(function (e, t) {\n              return {\n                data: e,\n                headIndex: t\n              };\n            }).filter(function (e) {\n              return s.toxicityLabels.indexOf(s.labels[e.headIndex]) > -1;\n            }).map(function (t) {\n              for (var n = t.data.dataSync(), r = [], o = 0; o < e.length; o++) {\n                var i = n.slice(2 * o, 2 * o + 2),\n                    a = null;\n                Math.max(i[0], i[1]) > s.threshold && (a = i[0] < i[1]), r.push({\n                  probabilities: i,\n                  match: a\n                });\n              }\n\n              return {\n                label: s.labels[t.headIndex],\n                results: r\n              };\n            })];\n        }\n      });\n    });\n  }, e;\n}();\n\nexport { load$1 as load, ToxicityClassifier };","map":null,"metadata":{},"sourceType":"module"}